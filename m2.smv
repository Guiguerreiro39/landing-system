MODULE main

VAR
    button: {down, up};
    phase: {halt_down, moving_up, halt_up, moving_down};
    dstate: {open, closed};
    lstate: {locked, unlocked};
    p: {retract_ready, extend_ready};
    completing: boolean;

ASSIGN
    init(button) := down;
    init(phase) := halt_down;
    init(dstate) := closed;
    init(lstate) := locked;
    init(p) := retract_ready;
    init(completing) := FALSE;

    next(phase) := case next(button) = button & dstate = closed & phase = moving_up & p = retract_ready: halt_up;
                        next(button) = button & dstate = closed & phase = moving_down & p = extend_ready: halt_down;

                        button = down & next(button) = up: moving_up;
                        button = up & next(button) = down: moving_down;

                        TRUE: phase;
                   esac;

    next(dstate) := case -- opening dstate (need to update next(p) with l & lstate)
                        next(button) = button & dstate = closed & lstate = unlocked & phase = moving_down & p = retract_ready: open; -- & l = retract_ready
                        next(button) = button & dstate = closed & lstate = unlocked & phase = moving_up & p = extend_ready: open; -- & l = extend_ready

                        -- closing dstate
                        next(button) = button & dstate = open & phase = moving_up & p = retract_ready: closed;
                        next(button) = button & dstate = open & phase = moving_down & p = extend_ready: closed;

                        TRUE: dstate;
                   esac;

    next(lstate) := case -- unlocking dstate up/down
                       next(button) = button & lstate = locked & phase = moving_up & p = extend_ready: unlocked;
                       next(button) = button & lstate = locked & phase = moving_down & p = retract_ready: unlocked;

                       -- locking dstate up/down
                       next(button) = button & dstate = closed & phase = moving_up & lstate = unlocked & p = retract_ready: locked;
                       next(button) = button & dstate = closed & phase = moving_down & lstate = unlocked & p = extend_ready: locked;

                       TRUE: lstate;
                  esac;

    next(completing) := case p = extend_ready & phase = moving_up & dstate = closed & lstate = locked & next(button) = down: TRUE;
                             p = retract_ready & phase = moving_down & dstate = closed & lstate = locked & next(button) = up: TRUE;

                             TRUE: FALSE;
                        esac;

    next(p) := case -- initiate retraction/extension
                    button = up & phase = halt_up & next(button) = down: retract_ready;
                    button = down & phase = halt_down & next(button) = up: extend_ready;

                    -- opening dstate
                    next(button) = button & dstate = closed & lstate = unlocked & phase = moving_down & p = retract_ready: extend_ready; -- & l = retract_ready
                    next(button) = button & dstate = closed & lstate = unlocked & phase = moving_up & p = extend_ready: retract_ready; -- & l = extend_ready

                    -- cancel retraction/extension (1)
                    completing = TRUE & phase = moving_down: retract_ready;
                    completing = TRUE & phase = moving_up: extend_ready;

                    -- cancel retraction/extension (2)
                    next(button) != button & dstate = open & phase = moving_up & p = retract_ready: extend_ready;
                    next(button) != button & dstate = open & phase = moving_down & p = extend_ready: retract_ready;

                    -- locking down/up
                    dstate = closed & phase = moving_down & lstate = unlocked & p = extend_ready: retract_ready;
                    dstate = closed & phase = moving_up & lstate = unlocked & p = retract_ready: extend_ready;
            
                    TRUE: p;
               esac;

TRANS
    -- Once the pilot cancels a retracting/extending order on the first stage, he must let it finish
    completing -> next(button) = button;

-- R11bis
CTLSPEC
    A [button = down U phase = halt_down] -> EF phase = halt_down & dstate = closed
-- -- R12bis
-- LTLSPEC
--     G (button = up U phase = halt_up -> dstate = closed & dstate = open)
-- -- R21
-- LTLSPEC
--     G (button = down -> phase != moving_up & phase != halt_up)
-- -- R22
-- LTLSPEC
--     G (button = up -> phase != moving_down & phase != halt_down)
-- LTLSPEC
--     G (phase = moving_up -> button = up)
-- LTLSPEC
--     G (phase = moving_down -> button = down)

-- LTLSPEC
--     G (dstate = open -> lstate = unlocked)
